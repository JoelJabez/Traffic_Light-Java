type: edu
files:
- name: src/traffic/Main.java
  visible: true
  text: |
    package traffic;

    public class Main {
      public static void main(String[] args){
        System.out.println("Hello World!");
      }
    }
  learner_created: false
- name: test/GlobalTests.java
  visible: false
  text: |-
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.TestPassed;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.TestedProgram;

    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.List;

    public class GlobalTests extends StageTest {

      int STAGE = 6;
      String name = "n3w_v3ry_unu5u4l_r04d_n4m3_";

      public void ForStages(int[] stages) {
        if (Arrays.binarySearch(stages, STAGE) < 0) {
          throw new TestPassed();
        }
      }

      static public void CheckMenu(String[] lines, String testCase) {
        String ADD_INFO = "Incorrect menu output in the following case: " + testCase + ". ";
        if (lines.length != 5) {
          throw new WrongAnswer(ADD_INFO + "It should contain exactly 5 lines but there were " + lines.length + " instead");
        }

        if (!lines[0].contains("menu")) {
          throw new WrongAnswer(ADD_INFO + "First line should " +
                  "contain \"Menu\" substring");
        }

        String[] starts = new String[]{"1", "2", "3", "0"};
        String[] contain = new String[]{"Add", "Delete", "System", "Quit"};
        for (int i = 0; i < starts.length; i++) {
          if (!lines[1 + i].startsWith(starts[i]) || !lines[1 + i].contains(contain[i].toLowerCase())) {
            throw new WrongAnswer(String.format(ADD_INFO + "The %d line of options' list should start with \"%s\" " +
                    "and contain \"%s\" substring as in example", i + 1, starts[i], contain[i]));
          }
        }
      }

      static public SystemOutput GetSystemInfo(String output, int roadsAmount, boolean parseRoads) {
        String[] lines = output.toLowerCase().split("[\r\n]+");
        if (lines.length != 4 && roadsAmount == 0) {
          throw new WrongAnswer("System information printed each second should contain exactly 4 " +
                  "non-empty lines, when no roads were added: one that shows amount of time since the start of the " +
                  "program, next two should show the provided initial settings and the last, that asks user to " +
                  "press Enter to show options, as in example");
        }
        if (roadsAmount != 0 && lines.length != 4 + roadsAmount) {
          throw new WrongAnswer("When the user provided any changes to queue, output of system mode should " +
                  "change. There should be exactly 4+n non-empty lines, where n is the amount of elements in " +
                  "queue, in such order, just like in the example:\n" +
                  "1. Line, that shows amount of time since the start of the program\n" +
                  "2. Line, that shows max number of elements, provided by user\n" +
                  "3. Line, that shows interval, provided by user\n" +
                  "...\n" +
                  "*queue*\n" +
                  "...\n" +
                  "n+4. Line, that that asks user to press 'Enter' to show options");
        }

        if (!lines[1].contains("number")) {
          throw new WrongAnswer("The line, that shows number of roads, provided by user, should contain " +
                  "\"number\" substring");
        }

        if (!lines[2].contains("interval")) {
          throw new WrongAnswer("The line, that shows interval, provided by user, should contain " +
                  "\"interval\" substring");
        }

        if (!lines[lines.length - 1].contains("enter")) {
          throw new WrongAnswer("The last line, that asks user to press Enter to show options should contain" +
                  " \"Enter\" substring");
        }

        return SystemOutput.parseStringInfo(lines, parseRoads);
      }

      static public int ProcessSystemSecondsInitial(SystemOutput info, int startSecond, int initRoads,
                                                    int initInterval) {
        if (startSecond != -1) {
          if (info.seconds != startSecond + 1) {
            throw new WrongAnswer("Time difference between two outputs (current and a second earlier)" +
                    " is not equal to 1:\nSecond earlier: " + startSecond + "\nCurrent: " + info.seconds);
          }
          if (info.maxRoads != initRoads) {
            throw new WrongAnswer("Line with initial setting (number of roads) shows incorrect value.");
          }
          if (info.interval != initInterval) {
            throw new WrongAnswer("Line with initial setting (interval) shows incorrect value.");
          }
        }
        return info.seconds;
      }

      public static Thread GetUsersThreadByName(String threadName) {
        Thread usersThread = null;
        for (Thread t : Thread.getAllStackTraces().keySet()) {
          if (t.getName().equals(threadName))
            usersThread = t;
        }
        if (usersThread == null) {
          throw new WrongAnswer("There should be created new thread when number of roads and interval settings were " +
                  "set, named as \"QueueThread\". Make sure, that it was created properly and was not misspelled");
        }
        return usersThread;
      }

      public String AwaitOutputAtStart(TestedProgram pr) {
        String output = null;
        int millisAwait = 0;
        boolean outputPerformed = false;
        while (millisAwait < 1050 && !outputPerformed) {
          try {
            Thread.sleep(50);
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
          millisAwait += 50;
          output = pr.getOutput().toLowerCase();
          if (!output.equals("")) {
            outputPerformed = true;
          }
        }
        if (output.equals("") || millisAwait > 1050) {
          throw new WrongAnswer("When the user selected '3' as an option, program should print new system " +
                  "information each second, but after 1 second of waiting there was no output.");
        }
        try {
          Thread.sleep(200);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
        String addOutput = pr.getOutput().toLowerCase();
        return output+addOutput;
      }

      public List<String> GetSystemOutputInSeconds(TestedProgram pr, int seconds) {
        String output = AwaitOutputAtStart(pr);
        if (seconds > 1) {
          try {
            Thread.sleep(1050 * (seconds-1));
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
          String newOutput = pr.getOutput().toLowerCase();
          output += newOutput;
        }
        List<String> outputs = new ArrayList<>();
        StringBuilder piece = new StringBuilder();
        for (String line : output.split("\\n")) {
          piece.append(line).append("\n");
          if (line.contains("enter")) {
            outputs.add(piece.toString());
            piece = new StringBuilder();
          }
        }
        if (!piece.toString().equals("")) {
          outputs.add(piece.toString());
        }
        return outputs;
      }

      public SystemOutput ProcessConditions(String output, String correct, SystemOutput previous, int roadsAmount,
                                            int interval, boolean reveal, String actionInBetween) {
        SystemOutput info = GetSystemInfo(output, roadsAmount, true);
        String[] roads = correct.equals("") ? new String[]{} : correct.split(";");

        if (info.roadLines.size() != roads.length) {
          throw new WrongAnswer("Incorrect number of roads was found in output after action: "
                  + (previous == null ? "Started." + actionInBetween : actionInBetween));
        }
        for (int j = 0; j < info.roadLines.size(); j++) {
          String[] data = roads[j].split(",");
          if (info.roadLines.get(j).isOpen() != data[0].equals("1")) {
            throw new WrongAnswer("Some roads describe their state incorrectly. Road should be \"closed\", " +
                    "but found \"open\" or vise versa."
                    + revealTest(previous, info, correct, actionInBetween, interval, reveal));
          }
          if (info.roadLines.get(j).seconds != Integer.parseInt(data[1])) {
            throw new WrongAnswer("Some roads' time to close/open is incorrect."
                    + revealTest(previous, info, correct, actionInBetween, interval, reveal));
          }
        }
        return info;
      }

      @DynamicTest(order = 0)
      CheckResult test_initial_and_menu() {

        TestedProgram pr = new TestedProgram();
        String output = pr.start().toLowerCase();

        String[] lines = output.split("[\r\n]+");

        if (lines.length != 2) {
          return CheckResult.wrong("There should be exactly 2 lines in the output when the program just started, " +
                  "but there were " + lines.length + " instead");
        }

        if (!lines[0].contains("welcome") || (!lines[0].contains("traffic management system"))) {
          return CheckResult.wrong("The first line of output should contain a greeting, as in example");
        }

        if (!lines[1].contains("input") || !lines[1].contains("number")) {
          return CheckResult.wrong("When the program just started, there should be a line, that asks user to input " +
                  "number of roads with \"Input\" and \"Number\" substrings");
        }

        output = pr.execute("5").toLowerCase();
        lines = output.split("[\r\n]+");

        if (lines.length != 1) {
          return CheckResult.wrong("There should be exactly 1 line printed when the user inputted desired number of " +
                  "roads, but there were " + lines.length + " instead");
        }

        if (!lines[0].contains("input") || !lines[0].contains("interval")) {
          return CheckResult.wrong("When the user provided number of roads, there should be a line, that asks user to " +
                  "input " +
                  "interval value with \"Input\" and \"Interval\" substrings");
        }

        output = pr.execute("3").toLowerCase();

        CheckMenu(output.split("[\r\n]+"), "Start of the program");

        pr.execute("0");
        if (!pr.isFinished()) {
          return CheckResult.wrong("After user inputted '0' as a desired option, program should finish it's execution");
        }

        return CheckResult.correct();
      }

      Object[][] stubs = {
              {"1", "add", 5},
              {"2", "delete", 5},
              {"3", "system", 4}
      };

      @DynamicTest(order = 1, data = "stubs")
      CheckResult test_stubs_and_quit(String option, String stubContain, int endStage) {
        if (STAGE <= 2 || STAGE >= endStage) {
          return CheckResult.correct();
        }
        TestedProgram pr = new TestedProgram();
        pr.start();

        for (String s : new String[]{"5", "3"})
          pr.execute(s);

        String output = pr.execute(option).toLowerCase();
        String[] lines = output.split("[\r\n]+");

        if (lines.length != 1 || !lines[0].contains(stubContain))
          return CheckResult.wrong(String.format("For \"%s\" option on current stage there should be a simple one-line " +
                  "stub, containing \"%s\" substring, followed by input to return back to menu", option, stubContain));

        output = pr.execute("").toLowerCase();

        CheckMenu(output.split("[\r\n]+"), String.format("Stub for \"%s\" option shown and blank input provided", option));

        if (pr.isFinished()) {
          return CheckResult.wrong("Option's selection should be looped");
        }
        pr.execute("0");
        if (!pr.isFinished()) {
          return CheckResult.wrong("After user inputted '0' as a desired option, program should finish it's execution");
        }

        return CheckResult.correct();
      }

      @DynamicTest(order = 2)
      CheckResult test_incorrect_initial() {
        ForStages(new int[]{3, 4, 5, 6});
        TestedProgram pr = new TestedProgram();
        pr.start();
        String output;

        String[] lines;

        for (String ex : new String[]{"asd", "-1", "6-", "0", "Hello world!"}) {
          output = pr.execute(ex).toLowerCase();
          lines = output.split("[\r\n]+");
          if (lines.length != 1 || !lines[0].contains("incorrect input") || !lines[0].contains("again")) {
            return CheckResult.wrong("When the user provides incorrect input for number of roads (<=0 or not " +
                    "numeric), there should be printed exactly one line, containing \"incorrect input\" and " +
                    "\"again\" substrings, followed by new input for number of roads");
          }
        }
        output = pr.execute("5").toLowerCase();
        lines = output.split("[\r\n]+");

        if (lines.length != 1) {
          return CheckResult.wrong("There should be exactly 1 line printed when the user inputted desired number of " +
                  "roads, " +
                  "but there were " + lines.length + " instead");
        }

        if (!lines[0].contains("input") || !lines[0].contains("interval")) {
          return CheckResult.wrong("When the user provided number of roads, there should be a line, that asks user to " +
                  "input " +
                  "interval value with \"Input\" and \"Interval\" substrings");
        }

        for (String ex : new String[]{"asd", "-1", "6-", "0", "Hello world!"}) {
          output = pr.execute(ex).toLowerCase();
          lines = output.split("[\r\n]+");
          if (lines.length != 1 || !lines[0].contains("incorrect input") || !lines[0].contains("again")) {
            return CheckResult.wrong("When the user provides incorrect input for interval value (<=0 or not " +
                    "numeric), there should be printed exactly one line, containing \"incorrect input\" and " +
                    "\"again\" substrings, followed by new input for interval value");
          }
        }
        output = pr.execute("5").toLowerCase();

        CheckMenu(output.split("[\r\n]+"), "Start of the program after correct input for initial settings");

        pr.execute("0");
        if (!pr.isFinished()) {
          return CheckResult.wrong("After user inputted '0' as a desired option, program should finish it's execution");
        }

        return CheckResult.correct();
      }

      @DynamicTest(order = 3)
      CheckResult test_incorrect_options() {
        ForStages(new int[]{3, 4, 5, 6});
        TestedProgram pr = new TestedProgram();
        pr.start();

        for (String s : new String[]{"5", "3"})
          pr.execute(s);

        String output;
        String[] lines;

        for (String ex : new String[]{"asd", "-1", "6-", "Hello world!", "4", "5"}) {
          output = pr.execute(ex).toLowerCase();
          lines = output.split("[\r\n]+");
          if (lines.length != 1 || !lines[0].contains("incorrect option")) {
            return CheckResult.wrong("When the user provides incorrect input while choosing an option (not '1', '2' or " +
                    "'3'), there should be printed exactly one line, containing \"incorrect option\" " +
                    "substring, followed by input to return back to menu");
          }
          output = pr.execute("").toLowerCase();
          CheckMenu(output.split("[\r\n]+"), "New iteration after incorrect input for option");
        }

        pr.execute("0");
        if (!pr.isFinished()) {
          return CheckResult.wrong("After user inputted '0' as a desired option, program should finish it's execution");
        }

        return CheckResult.correct();
      }

      String[] settings = {"1", "24367587"};

      @DynamicTest(data = "settings", order = 4)
      CheckResult test_system_info(String init) {
        ForStages(new int[]{4, 5, 6});
        TestedProgram pr = new TestedProgram();
        pr.start();

        for (String s : new String[]{init, init})
          pr.execute(s);

        Thread usersThread = GetUsersThreadByName("QueueThread");

        pr.execute("3");

        List<String> outputs = GetSystemOutputInSeconds(pr, 4);

        int prevSeconds = -1;
        for (String info : outputs) {
          SystemOutput soInfo = GetSystemInfo(info, 0, false);
          prevSeconds = ProcessSystemSecondsInitial(soInfo, prevSeconds, Integer.parseInt(init), Integer.parseInt(init));
        }

        String output = pr.execute("").toLowerCase();
        String[] lines = output.split("[\r\n]+");
        CheckMenu(lines, "Pressed \"Enter\" to return from system mode");

        pr.execute("3");
        pr.getOutput();

        String newOutput = GetSystemOutputInSeconds(pr, 1).get(0);
        SystemOutput soInfo = GetSystemInfo(newOutput, 0, false);
        ProcessSystemSecondsInitial(soInfo, prevSeconds, Integer.parseInt(init), Integer.parseInt(init));

        pr.execute("");
        pr.execute("0");

        if (!pr.isFinished()) {
          return CheckResult.wrong("After user inputted '0' as a desired option, program should finish it's " +
                  "execution");
        }

        try {
          usersThread.join(3000);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
        if (usersThread.isAlive()) {
          return CheckResult.wrong("You should kill the created thread when the program is finished");
        }

        return CheckResult.correct();
      }

      //init, action, resultType
      // 1 - queue is full
      // 2 - queue is empty
      // 3 - add
      // 4 - delete
      Object[][] dataForActions = {
              {"1", new String[]{"2", "1", "1", "2", "1"}, new int[]{2, 3, 1, 4, 3}},
              {"2", new String[]{"2", "1", "1", "1", "2", "2", "2", "1"}, new int[]{2, 3, 3, 1, 4, 4, 2, 3}}
      };

      @DynamicTest(data = "dataForActions", order = 5)
      CheckResult test_roads_menu_output(String init, String[] actions, int[] result) {
        ForStages(new int[]{5, 6});
        TestedProgram pr = new TestedProgram();
        pr.start();

        for (String s : new String[]{init, init})
          pr.execute(s);

        List<String> names = new ArrayList<>();

        for (int i = 0; i < actions.length; i++) {
          String output = pr.execute(actions[i]).toLowerCase();
          String[] lines = output.split("[\r\n]+");
          if (actions[i].equals("1")) {
            if (lines.length != 1 || !lines[0].contains("input")) {
              return CheckResult.wrong("When the user selected '1' as an option, program should print " +
                      "exactly 1 line, that contains \"input\" substring, followed by new input for " +
                      "element's name");
            }
            output = pr.execute(name + i).toLowerCase();
            lines = output.split("[\r\n]+");
          }
          switch (result[i]) {
            case 1: //QUEUE IS FULL
              if (lines.length != 1 || !output.contains("queue is full"))
                return CheckResult.wrong("When the user selected '1' as an option and provided new road's name, " +
                        "while queue is full, program should print exactly 1 line, that contains \"queue is full\" " +
                        "substring.");
              break;
            case 2: //QUEUE IS EMPTY
              if (lines.length != 1 || !output.contains("queue is empty"))
                return CheckResult.wrong("When the user selected '2' as an option, while queue is empty, " +
                        "program should print exactly 1 line, that contains \"queue is empty\" substring.");
              break;
            case 3: //ADD
              if (lines.length != 1 || !output.contains("add") || !output.contains(name + i))
                return CheckResult.wrong("When the user selected '1' as an option and successfully added new road, " +
                        "program should print exactly 1 line, that contains road's name and \"add\" substrings.");
              names.add(name + i);
              break;
            case 4: //DELETE
              if (lines.length != 1 || !output.contains("delete") || !output.contains(names.get(0)))
                return CheckResult.wrong("When the user selected '2' as an option and successfully removed a road, " +
                        "program should print exactly 1 line, that contains road's name and \"delete\" substrings.");
              names.remove(0);
              break;
          }
          CheckMenu(pr.execute("").toLowerCase().split("[\r\n]+"),
                  "New iteration after attempt to delete/add a road");
        }
        pr.execute("0");

        if (!pr.isFinished()) {
          return CheckResult.wrong("After user inputted '0' as a desired option, program should finish it's " +
                  "execution");
        }
        return CheckResult.correct();
      }


      @DynamicTest(data = "dataForActions", order = 6)
      CheckResult test_system_info_with_roads(String init, String[] actions, int[] result) {
        ForStages(new int[]{5, 6});
        TestedProgram pr = new TestedProgram();
        pr.start();

        for (String s : new String[]{init, init})
          pr.execute(s);

        List<String> names = new ArrayList<>();

        for (int i = 0; i < actions.length; i++) {
          pr.execute(actions[i]);
          if (actions[i].equals("1")) {
            pr.execute(name + i);
          }
          if (result[i] == 3)
            names.add(name + i);
          if (result[i] == 4)
            names.remove(0);
          pr.execute("");

          pr.execute("3");
          String output = GetSystemOutputInSeconds(pr, 1).get(0);
          SystemOutput info = GetSystemInfo(output, names.size(), false);

          if (info.roadLines.size() != names.size()) {
            return CheckResult.wrong("The amount of printed road lines from the system output is incorrect.");
          }

          for (int j = 0; j < names.size(); j++) {
            if (!info.roadLines.get(j).line.contains(names.get(j))) {
              return CheckResult.wrong("Between settings lines and the line, that asks user to press Enter to show " +
                      "options, there should be printed all elements in queue from front to rear, containing " +
                      "elements' names in such order.");
            }
          }

          pr.execute("");
        }
        pr.execute("0");

        if (!pr.isFinished()) {
          return CheckResult.wrong("After user inputted '0' as a desired option, program should finish it's " +
                  "execution.");
        }
        return CheckResult.correct();
      }

      @DynamicTest(data = "finalActionsSimple", order = 7)
      CheckResult test_roads_conditions_simple(int maxRoads, int interval, boolean reveal, String[] correct) {
        ForStages(new int[]{6});

        TestedProgram pr = new TestedProgram();
        pr.start();

        for (String s : new String[]{String.valueOf(maxRoads), String.valueOf(interval)})
          pr.execute(s);

        for (int i = 0; i < maxRoads; i++) {
          pr.execute("1");
          pr.execute(name + i);
          pr.execute("");
        }

        pr.execute("3");
        List<String> outputs = GetSystemOutputInSeconds(pr, interval * (maxRoads + 1));

        pr.execute("");
        pr.execute("0");

        if (!pr.isFinished()) {
          return CheckResult.wrong("After user inputted '0' as a desired option, program should finish it's " +
                  "execution.");
        }

        if (outputs.size() < correct.length) {
          return CheckResult.wrong("Incorrect number of system outputs was found. Make sure, that system prints new info" +
                  " each second");
        }

        SystemOutput previousUsers = null;

        for (int i = 0; i < correct.length; i++) {
          previousUsers = ProcessConditions(outputs.get(i), correct[i], previousUsers, maxRoads, interval, reveal,
                  previousUsers == null ? "Added " + maxRoads + " roads." : "Waited 1 second.");
        }

        return CheckResult.correct();
      }

      @DynamicTest(data = "finalActionsAdvanced", order = 8)
      CheckResult test_roads_conditions_advanced(int maxRoads, int interval, boolean reveal, String[] correct) {
        ForStages(new int[]{6});

        TestedProgram pr = new TestedProgram();
        pr.start();
        for (String s : new String[]{String.valueOf(maxRoads), String.valueOf(interval)})
          pr.execute(s);

        SystemOutput previousUsers = null;

        int amountOfRoads = 0;

        int j = 0;
        for (int i = 0; i < maxRoads; i++) {
          pr.execute("1");
          pr.execute(name + i);
          pr.execute("");
          pr.execute("3");

          String output = GetSystemOutputInSeconds(pr, 1).get(0);
          previousUsers = ProcessConditions(output, correct[j++], previousUsers, ++amountOfRoads, interval, reveal,
                  previousUsers == null ? "Added 1 road." : "Added 1 road. Waited 1 second.");
          pr.execute("");
        }

        pr.execute("3");
        String output = GetSystemOutputInSeconds(pr, 1).get(0);
        previousUsers = ProcessConditions(output, correct[j++], previousUsers, amountOfRoads, interval, reveal,
                "Waited 1 second.");
        pr.execute("");

        for (int i = 0; i < maxRoads; i++) {
          pr.execute("2");
          pr.execute("");
          pr.execute("3");

          List<String> outputs = GetSystemOutputInSeconds(pr, 2);
          amountOfRoads--;
          previousUsers = ProcessConditions(outputs.get(0), correct[j++], previousUsers, amountOfRoads, interval, reveal,
                  "Deleted 1 road. Waited 1 second.");
          previousUsers = ProcessConditions(outputs.get(1), correct[j++], previousUsers, amountOfRoads, interval, reveal,
                  "Waited 1 second.");
          pr.execute("");
        }
        pr.execute("0");

        return CheckResult.correct();
      }

      String revealTest(SystemOutput previousUsers, SystemOutput usersOutput, String correct, String actionInBetween,
                        int interval, boolean reveal) {
        if (!reveal)
          return "";
        String[] correctRoads = correct.split(";");
        if (previousUsers == null) {
          actionInBetween = "Started. " + actionInBetween;
        }
        String output = "---Interval: " + interval + "---\n";
        if (previousUsers != null) {
          output = output.concat("...\n");
          for (Road r : previousUsers.roadLines) {
            output = output.concat(r.toString() + "\n");
          }
        }
        output = output.concat("---Performed action: " + actionInBetween + "---\n");

        String expected = "", got = "";
        for (int j = 0; j < usersOutput.roadLines.size(); j++) {
          String[] data = correctRoads[j].split(",");
          String gotOutput = usersOutput.roadLines.get(j).toString() + "\n";
          int gotSeconds = usersOutput.roadLines.get(j).seconds;
          got = got.concat(gotOutput);

          if (usersOutput.roadLines.get(j).isOpen() != data[0].equals("1")) {
            gotOutput = gotOutput.replace("closed", "^*#")
                    .replace("open", "closed")
                    .replace("^*#", "open");
          }
          if (gotSeconds != Integer.parseInt(data[1])) {
            gotOutput = gotOutput.replace(gotSeconds + "s.", data[1] + "s.");
          }
          expected = expected.concat(gotOutput);
        }
        if (expected.equals("")) {
          expected = "(No roads)\n";
        }
        if (got.equals("")) {
          got = "(No roads)\n";
        }
        return " Formal snippet of expected/got output:\n" + output + "---Expected:---\n" + expected + "---Got:---\n" + got;
      }


      //maxRoads, interval, reveal, correct
      //2 roads, with interval 2
      //3 roads, with interval 1
      //4 roads, with interval 3
      //4 roads, with interval 1
      Object[][] finalActionsSimple = {
              {2, 2, true, new String[]{"1,2;0,2", "1,1;0,1", "0,2;1,2", "0,1;1,1", "1,2;0,2", "1,1;0,1"}},
              {2, 1, true, new String[]{"1,1;0,1", "0,1;1,1", "1,1;0,1"}},
              {3, 3, false, new String[]{"1,3;0,3;0,6", "1,2;0,2;0,5", "1,1;0,1;0,4",
                      "0,6;1,3;0,3", "0,5;1,2;0,2", "0,4;1,1;0,1",
                      "0,3;0,6;1,3", "0,2;0,5;1,2", "0,1;0,4;1,1",
                      "1,3;0,3;0,6", "1,2;0,2;0,5", "1,1;0,1;0,4"}
              },
              {3, 1, false, new String[]{"1,1;0,1;0,2", "0,2;1,1;0,1", "0,1;0,2;1,1", "1,1;0,1;0,2"}}
      };
      //2 roads, with interval 2, 1 road, 1 seconds, 1 road, 2 seconds, remove road, 2 seconds, remove road, 2 seconds
      //3 roads, with interval 3, 1 road, 1 seconds, 1 road, 1 seconds, 1 road, 2 seconds, remove road, 2 seconds, remove
      // road, 2 seconds, remove road, 2 seconds
      Object[][] finalActionsAdvanced = {
              {2, 2, true, new String[]{"1,2", "1,1;0,1", "0,2;1,2", "1,1", "1,2", "", ""}},
              {3, 3, false, new String[]{"1,3", "1,2;0,2", "1,1;0,1;0,4", "0,6;1,3;0,3", "1,2;0,2", "1,1;0,1", "1,3",
                      "1,2", "", ""}
              }
      };
    }
  learner_created: false
- name: test/SystemOutput.java
  visible: false
  text: |
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;

    public class SystemOutput {
      int interval, maxRoads, seconds;
      List<Road> roadLines;

      private SystemOutput(int interval, int maxRoads, int seconds, List<Road> roadLines) {
        this.interval = interval;
        this.maxRoads = maxRoads;
        this.seconds = seconds;
        this.roadLines = roadLines;
      }

      public static SystemOutput parseStringInfo(String[] lines, boolean parseRoads) {
        Pattern pattern = Pattern.compile("(\\D*)(\\d+)(\\D*)");

        Matcher matcher =pattern.matcher(lines[0]);
        if (!matcher.matches()) {
          throw new WrongAnswer("The line, that shows time since the start of the program, should contain " +
                  "only one integer - amount of seconds");
        }
        int seconds = Integer.parseInt(matcher.group(2));

        matcher =pattern.matcher(lines[1]);
        if (!matcher.matches()) {
          throw new WrongAnswer("The line, that shows number of roads, provided by user, should contain " +
                  "only one integer - exact number, that was set by user");
        }
        int maxRoads = Integer.parseInt(matcher.group(2));

        matcher =pattern.matcher(lines[2]);
        if (!matcher.matches()) {
          throw new WrongAnswer("The line, that shows interval, provided by user, should contain " +
                  "only one integer - interval, that was set by user");
        }
        int interval = Integer.parseInt(matcher.group(2));

        List<Road> roadLines = new ArrayList<>();
        for(int i=3;i<lines.length-1;i++){
          roadLines.add(new Road(lines[i], parseRoads));
        }
        return new SystemOutput(interval, maxRoads, seconds, roadLines);
      }
    }

    class Road {
      String line;
      int seconds;

      Road(String line, boolean parseRoads){
        this.line = line;
        if(parseRoads) {
          if (!line.contains("open") && !line.contains("closed")) {
            throw new WrongAnswer("All lines with elements in queue should contain \"open\" or \"closed\" " +
                    "substring, describing it's state.");
          }
          Pattern pattern = Pattern.compile("((?!(\\d+)s\\.).)*(\\d+)s\\.((?!(\\d+)s\\.).)*");
          Matcher matcher =pattern.matcher(line);
          if (!matcher.matches()) {
            throw new WrongAnswer("All lines with elements in queue should contain only one \"Ns.\" substring " +
                    "(where N is a number) - amount of seconds until it closes/opens");
          }
          seconds = Integer.parseInt(matcher.group(3));
        }else{
          seconds = -1;
        }
      }

      boolean isOpen() {
        return line.contains("open");
      }

      @Override
      public String toString() {
        int index = line.indexOf("n3w_v3ry_unu5u4l_r04d_n4m3_");
        return "Road"+line.charAt(index+27)+", "+(isOpen()?"open":"closed")+", "+seconds+"s.";
      }
    }
  learner_created: false
- name: src/traffic/light/CircularQueue.java
  visible: true
  text: "package traffic.light;\n\nclass CircularQueue {\n\tprivate String[] roadArray;\n\
    \tprivate final int capacity;\n\tprivate int front = 0;\n\tprivate int rear =\
    \ -1;\n\tprivate int numberOfRoads = 0;\n\n\tCircularQueue(int capacity) {\n\t\
    \tthis.capacity = capacity;\n\t\troadArray = new String[capacity];\n\t}\n\n\t\
    void enqueue(String road) {\n\t\tint index = (rear + 1) % capacity;\n\n\t\tif\
    \ (numberOfRoads == capacity) {\n\t\t\tSystem.out.println(\"queue is full\");\n\
    \t\t\treturn;\n\t\t}\n\t\tif (front >= capacity) {\n\t\t\tfront = 0;\n\t\t}\n\n\
    \t\troadArray[index] = road;\n\t\tnumberOfRoads++;\n\t\trear++;\n\n\t\tSystem.out.println(road\
    \ + \" Added!\");\n\t}\n\n\tvoid dequeue() {\n\t\tif (numberOfRoads == 0) {\n\t\
    \t\tSystem.out.println(\"queue is empty\");\n\t\t\treturn;\n\t\t}\n\t\tint index\
    \ = front % capacity;\n\n\t\tSystem.out.println(roadArray[index] + \" deleted!\"\
    );\n\t\tfront++;\n\t\tnumberOfRoads--;\n\t}\n\n\tvoid listRoads() {\n\t\tif (numberOfRoads\
    \ != 0) {\n\t\t\tint index = front;\n\n\t\t\tSystem.out.println();\n\t\t\tfor\
    \ (int counter = 0; counter < numberOfRoads; counter++) {\n\t\t\t\tSystem.out.println(roadArray[index]);\n\
    \n\t\t\t\tindex++;\n\t\t\t\tindex %= capacity;\n\t\t\t}\n\t\t\tSystem.out.println();\n\
    \t\t}\n\t}\n}\n"
  learner_created: true
- name: src/traffic/light/TrafficLight.java
  visible: true
  text: "package traffic.light;\n\nimport java.util.Scanner;\nimport java.io.IOException;\n\
    \npublic class TrafficLight {\n\tThread systemThread;\n\tThread menuThread;\n\t\
    CircularQueue queue;\n\tScanner scanner = new Scanner(System.in);\n\tString exit\
    \ = \"\";\n\tint numberOfRoads;\n\tint numberOfIntervals;\n\tint time = 0;\n\t\
    boolean stopThread = false;\n\n\tpublic void start() {\n\t\tSystem.out.println(\"\
    Welcome to the traffic management system!\");\n\n\t\tnumberOfRoads = getInput(\"\
    Input the number of roads: \");\n\t\tnumberOfIntervals = getInput(\"Input the\
    \ interval: \");\n\n\t\tqueue = new CircularQueue(numberOfRoads);\n\n\t\tString\
    \ input;\n\t\tcreateMenuThread();\n\t\tmenuThread.start();\n\t\tdo {\n\t\t\texit\
    \ = \"\";\n\n\t\t\tclearScreen();\n\t\t\tprintControlPanel();\n\n\t\t\tinput =\
    \ scanner.nextLine();\n\t\t\tswitch (input) {\n\t\t\t\tcase \"1\" -> addRoad();\n\
    \t\t\t\tcase \"2\" -> deleteRoad();\n\t\t\t\tcase \"3\" -> openSystem();\n\t\t\
    \t\tcase \"0\" -> {\n\t\t\t\t\texit();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\
    \tdefault -> {\n\t\t\t\t\tSystem.out.println(\"Incorrect option\");\n\t\t\t\t\t\
    scanner.nextLine();\n\t\t\t\t}\n\t\t\t}\n\t\t} while (true);\n\t}\n\n\tprivate\
    \ void addRoad() {\n\t\tSystem.out.print(\"Input road name: \");\n\t\tString roadName\
    \ = scanner.nextLine();\n\n\t\tqueue.enqueue(roadName);\n\n\t\tscanner.nextLine();\n\
    \t}\n\n\tprivate void deleteRoad() {\n\t\tqueue.dequeue();\n\t\tscanner.nextLine();\n\
    \t}\n\n\tprivate void openSystem() {\n\t\tmenuThread.interrupt();\n\n\t\tstopThread\
    \ = false;\n\t\texit = null;\n\n\t\tcreateSystemThread();\n\t\tsystemThread.start();\n\
    \n\t\texit = scanner.nextLine();\n\t\tstopThread = true;\n\n\t\tcreateMenuThread();\n\
    \t\tmenuThread.start();\n\t}\n\n\tprivate void exit() {\n\t\tSystem.out.println(\"\
    Bye!\");\n\t}\n\n\tprivate void sleep() {\n\t\ttry {\n\t\t\tThread.sleep(1000);\n\
    \t\t} catch (InterruptedException ignored) {\n\t\t}\n\t}\n\n\tprivate void createSystemThread()\
    \ {\n\t\tsystemThread = new Thread(() -> {\n\t\t\twhile (!stopThread) {\n\t\t\t\
    \tif (exit != null) {\n\t\t\t\t\tsystemThread.interrupt();\n\t\t\t\t\tbreak;\n\
    \t\t\t\t}\n\t\t\t\tclearScreen();\n\n\t\t\t\tSystem.out.printf(\"! %ds. have passed\
    \ since system startup !\\n\", time);\n\t\t\t\tSystem.out.printf(\"! Number of\
    \ roads: %d !\\n\", numberOfRoads);\n\t\t\t\tSystem.out.printf(\"! Interval: %d\
    \ !\\n\", numberOfIntervals);\n\t\t\t\tqueue.listRoads();\n\t\t\t\tSystem.out.println(\"\
    ! Press \\\"Enter\\\" to open menu !\");\n\n\t\t\t\ttimer();\n\t\t\t}\n\t\t});\n\
    \t}\n\n\tprivate void timer() {\n\t\tsleep();\n\t\ttime++;\n\t}\n\n\tprivate void\
    \ createMenuThread() {\n\t\tmenuThread = new Thread(this::timer, \"QueueThread\"\
    );\n\t}\n\n\tvoid printControlPanel() {\n\t\tSystem.out.println(\"Menu:\");\n\t\
    \tSystem.out.println(\"1. Add road\");\n\t\tSystem.out.println(\"2. Delete road\"\
    );\n\t\tSystem.out.println(\"3. Open system\");\n\t\tSystem.out.println(\"0. Quit\"\
    );\n\t}\n\n\tvoid clearScreen() {\n\t\ttry {\n\t\t\tvar clearCommand = System.getProperty(\"\
    os.name\").contains(\"Windows\")\n\t\t\t\t? new ProcessBuilder(\"cmd\", \"/c\"\
    , \"cls\")\n\t\t\t\t: new ProcessBuilder(\"clear\");\n\t\t\tclearCommand.inheritIO().start().waitFor();\n\
    \t\t} catch (IOException | InterruptedException ignored) {\n\t\t}\n\t}\n\n\tint\
    \ getInput(String message) {\n\t\tString stringNumber;\n\t\tint number;\n\t\t\
    try {\n\t\t\tSystem.out.print(message);\n\t\t\tstringNumber = scanner.nextLine();\n\
    \t\t\tnumber = Integer.parseInt(stringNumber);\n\n\t\t\tif (number < 1) {\n\t\t\
    \t\treturn handleException();\n\t\t\t}\n\t\t} catch (NumberFormatException ime)\
    \ {\n\t\t\treturn handleException();\n\t\t}\n\t\treturn number;\n\t}\n\n\tint\
    \ handleException() {\n\t\tString stringNumber;\n\t\tint number;\n\t\tdo {\n\t\
    \t\ttry {\n\t\t\t\tSystem.out.print(\"Error! Incorrect input. Try again: \");\n\
    \t\t\t\tstringNumber = scanner.nextLine();\n\t\t\t\tnumber = Integer.parseInt(stringNumber);\n\
    \t\t\t\tif (number >= 1) {\n\t\t\t\t\treturn number;\n\t\t\t\t}\n\n\t\t\t} catch\
    \ (NumberFormatException ignored) {\n\t\t\t}\n\t\t} while (true);\n\t}\n}\n"
  learner_created: true
- name: buildAndRun.sh
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/22727#comment
status: Failed
feedback:
  message: "Wrong answer in test #13\n\nSome roads&#39; time to close/open is incorrect.\
    \ Formal snippet of expected/got output:\n---Interval: 2---\n---Performed action:\
    \ Started. Added 2 roads.---\n---Expected:---\nRoad0, open, 2s.\nRoad1, closed,\
    \ 2s.\n---Got:---\nRoad0, open, 1s.\nRoad1, closed, 1s.\n\nPlease find below the\
    \ output of your program during this failed test.\nNote that the &#39;&gt;&#39;\
    \ character indicates the beginning of the input line.\n\n---\n\nWelcome to the\
    \ traffic management system!\nInput the number of roads: &gt; 2\nInput the interval:\
    \ &gt; 2\nMenu:\n1. Add road\n2. Delete road\n3. Open system\n0. Quit\n&gt; 1\n\
    Input road name: &gt; n3w_v3ry_unu5u4l_r04d_n4m3_0\nn3w_v3ry_unu5u4l_r04d_n4m3_0\
    \ Added!\n&gt; \nMenu:\n1. Add road\n2. Delete road\n3. Open system\n0. Quit\n\
    &gt; 1\nInput road name: &gt; n3w_v3ry_unu5u4l_r04d_n4m3_1\nn3w_v3ry_unu5u4l_r04d_n4m3_1\
    \ Added!\n&gt; \nMenu:\n1. Add road\n2. Delete road\n3. Open system\n0. Quit\n\
    &gt; 3\n! 1s. have passed since system startup !\n! Number of roads: 2 !\n! Interval:\
    \ 2 !\n\nn3w_v3ry_unu5u4l_r04d_n4m3_0 will be opened for 1s.\nn3w_v3ry_unu5u4l_r04d_n4m3_1\
    \ will be closed for 1s.\n\n! Press &quot;Enter&quot; to open menu !\n! 2s. have\
    \ passed since system startup !\n! Number of roads: 2 !\n! Interval: 2 !\n\nn3w_v3ry_unu5u4l_r04d_n4m3_0\
    \ will be closed for 2s.\nn3w_v3ry_unu5u4l_r04d_n4m3_1 will be opened for 2s.\n\
    \n! Press &quot;Enter&quot; to open menu !\n! 3s. have passed since system startup\
    \ !\n! Number of roads: 2 !\n! Interval: 2 !\n\nn3w_v3ry_unu5u4l_r04d_n4m3_0 will\
    \ be closed for 1s.\nn3w_v3ry_unu5u4l_r04d_n4m3_1 will be opened for 1s.\n\n!\
    \ Press &quot;Enter&quot; to open menu !\n! 4s. have passed since system startup\
    \ !\n! Number of roads: 2 !\n! Interval: 2 !\n\nn3w_v3ry_unu5u4l_r04d_n4m3_0 will\
    \ be opened for 2s.\nn3w_v3ry_unu5u4l_r04d_n4m3_1 will be closed for 2s.\n\n!\
    \ Press &quot;Enter&quot; to open menu !\n! 5s. have passed since system startup\
    \ !\n! Number of roads: 2 !\n! Interval: 2 !\n\nn3w_v3ry_unu5u4l_r04d_n4m3_0 will\
    \ be opened for 1s.\nn3w_v3ry_unu5u4l_r04d_n4m3_1 will be closed for 1s.\n\n!\
    \ Press &quot;Enter&quot; to open menu !\n! 6s. have passed since system startup\
    \ !\n! Number of roads: 2 !\n! Interval: 2 !\n\nn3w_v3ry_unu5u4l_r04d_n4m3_0 will\
    \ be closed for 2s.\nn3w_v3ry_unu5u4l_r04d_n4m3_1 will be opened for 2s.\n\n!\
    \ Press &quot;Enter&quot; to open menu !\n&gt; \nMenu:\n1. Add road\n2. Delete\
    \ road\n3. Open system\n0. Quit\n&gt; 0\nBye!"
  time: "Thu, 20 Jul 2023 09:37:12 UTC"
record: 6
